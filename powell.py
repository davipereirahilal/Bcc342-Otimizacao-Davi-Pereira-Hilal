# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13d8FKrWoC44hNvqmCYaY-tagwEx92aAq
"""

import numpy as np
from os import name
import math
import matplotlib.pyplot as plt

def bracketing(a,f,s=0.01,m=2):
    b = a + s

    fa=f(a)
    fb=f(b)
    if fa > fb :
        c=b+s
        fc=f(c)
        while fc < fb :
                fb=fc
                b=c
                s=s*m
                c=c+s
                fc=f(c)
        bracketing =[a,c]
        
    
    if fb > fa:
            a=b-s
            c=a-s
            fc=f(c)
            while fc < fa :
            
                    fa=fc
                    a=c
                    s=s*m
                    c=c-s
                    fc=f(c)
                    
            bracketing = [c,b]

    return bracketing

def interpolacaoquadratica(f,a,b,tol=1e-6):
  c = b
  b = (c-a)/2

  fa = f(a)
  fb = f(b)
  fc = f(c)

  while abs(c-a) < tol:
    x = 0.5*(fa*(b**2-c**2)+fb*(c**2-a**2)+fc*(a**2-b**2))/(fa*(b-c) +fb*(c-a) +fc*(a-b))
    fx = f(x)
    print(x)
    if x > b:
      if fx > fb:
        c = x
        fc = fx
      else: 
        a = b
        fa = fb
        b = x
        fb = fx
    else:
      if fx > fb:
        a = x
        fa = fx
      else:
        c = b
        fc = fb
        b = x
        fb = fx

  return (a+c)/2

def perform_line_search(x,f,s,inter,tol):
    f_aux = lambda a : f(x + a*s)
    bracket = bracketing(0,f_aux)
    alpha = inter(f_aux,bracket[0],bracket[1],tol=tol)
    return alpha

def powell(x,f,tol=1e-6,inter=interpolacaoquadratica):

    lx = [x]
    lfx = [f(x)]
    directions = []

    for i in range(len(x)):
        directions.append(np.zeros(len(x)))
        directions[i][i] = 1

    s = directions[-1]
    alpha = peformacebracketing(x,f,s,inter,tol)
    x = x + alpha*s

    lx.append(x)
    lfx.append(f(x))

    while np.linalg.norm(s) > tol:

        z = x
        i = 0

        while i < len(x) and np.linalg.norm(s) > tol:
            
            s = directions[i]
            alpha = peformacebracketing(x,f,s,inter,tol)
            x = x + alpha*directions[i]

            lx.append(x)
            lfx.append(f(x))

            i = i+1

        s = x - z
        alpha = peformacebracketing(x,f,s,inter,tol)
        x = x + alpha*s

        lx.append(x)
        lfx.append(f(x))

        directions.pop(0)
        directions.append(s)

    return x,f(x),lx,lfx